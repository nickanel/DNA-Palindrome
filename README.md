# DNA-Palindrome
N.Κανελλόπουλος  3090070
Κ.Κοντούλης      3090089
Επεξήγηση Υλοποίησης μέρη Α-Β
 Αρχικώς υλοποιήσαμε την μέθοδο isEmpty(). Πολύ απλά, αν η κεφαλή ( head) της λίστας ισούται με το μηδέν, τότε η λίστα είναι άδεια.
 Στη συνέχεια προχωρήσαμε με την υλοποίηση της μεθόδου push(char item). Η μέθοδος αυτή ωθεί ένα στοιχείο τύπου char στη στοίβα. Αυτό επιτυγχάνεται με την δημιουργία ενός νέου αντικειμένου τύπου Node.
 To αντίθετο ακριβώς καλείται να κάνει η μέθοδος pop(), να αφαιρέσει δηλαδή ένα στοιχείο απο την λίστα. Προφανώς, εφόσον χειριζόμαστε τη λίστα ως στοίβα το στοιχείο αυτό θα είναι αυτό που βρίσκεται στην κορυφή της. Τοποθετούμε λοιπόν το στοιχείο που πρέπει να αφαιρέσουμε σε μία μεταβλητή και ορίζουμε το επόμενο στοιχείο στο οποίο πρέπει να δείχνει ο δείκτης head, ώστε να μην μείνει ακέφαλη η στοίβα μας.
 Ακολουθεί η υλοποίηση της μεθόδου printStack(PrintStream stream). Η μέθοδος πρέπει να εκτυπώνει τα περιεχόμενα της στοίβας από πάνω προς τα κάτω στο stream που της δίνεται ως όρισμα. Εξετάζουμε λοιπόν πρώτα την περίπτωση που η στοίβα είναι κενή και εμφανίζουμε κατάλληλο μήνυμα. Αν η στοίβα περιέχει στοιχεία , για το κάθε ένα απο αυτά τα στοιχεία και ξεκινώντας από το πιο πάνω, εκτυπώνουμε το περιεχόμενο του με την εντολή stream.printf( "%s ", head.item ).
 Τέλος η υλοποίηση της size() στηρίζεται στην συνθήκη «Όσο η λίστα δεν έιναι κενή, αύξησε τον μετρητή κατά ένα».
 Στο μέρος Β χρησιμοποιήσαμε κάποιες από τις υλοποιημένες μεθόδους του interface που μας δόθηκε, για να επιλύσουμε το πρόβλημα. Πιο συγκεκριμένα, στην κλάση palindrome, στην main του προγράμματος μας τοποθετούμε με την μέθοδο push(char item) ένα γράμμα στην στοίβα. Χρησιμοποιούμε επίσης την μέθοδο pop() ανακτώντας το πρώτο στοιχείο της στοίβας, για να πραγματοποιήσουμε ουσιαστικά τη σύγκριση μεταξύ των γραμμάτων μιας λέξης ώστε να την ορίσουμε ή όχι ως παλινδρομική.
Επεξήγηση Υλοποίησης μέρη Γ-Δ
 public boolean isEmpty():Είναι μια μέθοδος η οποία ελέγχει την τιμή του αρχικού κόμβου και ανάλογα με αυτήν επιστρέφει μια Boolean τιμή.
 public void addFirst(char item): Είναι μια μέθοδος της κλάσης που εισάγει ένα αντικείμενο τύπου char στην αρχή της διπλά συνδεδεμένης λίστας μας. Αρχικά ελέγχει εάν είναι άδεια ώστε να αρχικοποιήσει και head tail και pre_tail στον ίδιο κόμβο μιας και θα υπάρχει ένα μόνο στοιχείο στη λίστα. Διαφορετικά θέτει στον επόμενο κόμβο της κεφαλής την τιμή της κεφαλής και στη θέση της κεφαλής (head Node) τοποθετεί τον νέο κόμβο. Δε χρησιμοποιείται επαναληπτική δομή οπότε η εισαγωγή γίνεται σε χρόνο O(1.)
 public char removeFirst() : Η μέθοδος αυτή αφαιρεί το πρώτο στοιχείο της λίστας. Ελέγχει αρχικά εάν η λίστα δεν είναι άδεια αλλιώς πετά εξαίρεση . Εάν δεν είναι άδεια τότε κρατά σε μία μεταβλητή το πρώτο στοιχείο και μετατοπίζει την κεφαλή ώστε να δείχνει πλέον στον επόμενο κόμβο. Δε χρησιμοποιείται επαναληπτική δομή οπότε η εξαγωγή γίνεται σε χρόνο O(1.)
 public void addLast(char item): Τοποθετεί ένα char στο τέλος της λίστας. Αρχικά ελέγχει εάν είναι άδεια ώστε να αρχικοποιήσει και head tail και pre_tail στον ίδιο κόμβο μιας και θα υπάρχει ένα μόνο στοιχείο στη λίστα. Εάν δεν είναι άδεια τότε θέτει τον επόμενο κόμβο της ουράς να είναι ο καινούργιος κόμβος, τον προηγούμενο κόμβο της ουράς να δείχνει στο pre_tail .Θέτει το Pre_tail να δείχνει εκεί που έδειχνε το tail Και ορίζει το tail Να δείχνει στον καινούργιο κόμβο που είναι και το τελευταίο στοιχείο της λίστας. Δε χρησιμοποιείται επαναληπτική δομή οπότε η εισαγωγή γίνεται σε χρόνο O(1.)
 public char removeLast():Η μέθοδος αυτή αφαιρεί το τελευταίο στοιχείο της λίστας. Ελέγχει αρχικά εάν η λίστα δεν είναι άδεια αλλιώς πετά εξαίρεση .Εαν δεν είναι άδεια τότε σώζει σε μια μεταβλητή την τιμή του τελευταίου κόμβου,έπειτα εάν είναι ένας κόμβος αρχικοποιεί head tail pre_tail στο null,εαν όχι τότε χρησιμοποιεί μια βοηθητική μεταβλητή temp και θέτει το tail στον προηγούμενο κόμβο. Δε χρησιμοποιείται επαναληπτική δομή οπότε η εξαγωγή γίνεται σε χρόνο O(1.)
 public char getFirst(): Ελέγχει εάν η λίστα είναι άδεια και πετά εξαίρεση. Επιστρέφει τα δεδομένα του Head Με τη χρήση βοηθητικής μεταβλητής.
 public char getLast():Ελέγχει εάν η λίστα είναι άδεια και πετά εξαίρεση. Επιστρέφει τα δεδομένα του Tail Με τη χρήση βοηθητικής μεταβλητής.
 public void printQueue(PrintStream stream):Ελέγχει εάν η λίστα είναι άδεια και εκτυπώνει την παραπάνω πληροφορία. Διαφορετικά εκτυπώνει όλα τα στοιχεία της λίστας χρησιμοποιώντας την μέθοδο printf.
 public int size(): Χρησιμοποιεί ένας αρχικοποιημένο στο μηδέν μετρητή και αφού διανύσει όλη τη λίστα επιστρέφει το προσαυξημένο από κάθε επανάληψη νούμερο .
Υλοποίηση του «πελάτη» DNAPalindrome
Οι βασικές απαιτήσεις είναι να χρησιμοποιήσουμε μια μόνο λίστα ,1)με την οποία να εισάγουμε την ακολουθία που μας δίνει ο χρήστης, μέσω του αντικείμενου Scanner2) να μετατρέψουμε κάθε στοιχείο στο συμπληρωματικό του και 3)έπειτα να αντιστρέψουμε τη σειρά των κόμβων ,4)ελέγχοντας στο τέλος πάλι με την ίδια λίστα εάν είναι η ακολουθία νουκλεοτιδίων Watson-Crick.
Αρχικά με τη χρήση του αντικειμένου Scanner διαβάζουμε τα δεδομένα του χρήστη-πελάτη και με την χρήση μιας Boolean μεθόδου(public static boolean Watson_Crick(String sequence_2)) που δημιουργήσαμε μέσα στη Main μας εκτυπώνουμε τα κατάλληλα μηνύματα.
Στην public static boolean Watson_Crick(String sequence_2)
αρχικά δημιουργούμε ένα αντικείμενο διπλά συνδεμένης λίστας ώστε να μπορούμε να χρησιμοποιήσουμε τις μεθόδους μας.
Δεν μας τίθεται θέμα πολυπλοκότητας οπότε μπορούμε να χρησιμοποιήσουμε επαναληπτικές δομές, έπειτα δηλώνουμε ένα χαρακτήρα ώστε να επεξεργαστούμε το όρισμα από την κλήση της συνάρτησης μας από την main.Ελέγχουμε αρχικά εάν είναι χαρακτήρας το πρώτο γράμμα της λέξης μας. Έπειτα το εισάγουμε στο μπροστινό άκρο της λίστας. Ελέγχουμε την τιμή του και το αντικαθιστούμε με το συμπληρωματικό του. Αυτό θα πραγματοποιηθεί για όλα τα chars του διαβασμένου string μέσω της επαναληπτικής δομής for που χρησιμοποιείται. Έτσι καλύπτονται οι δύο πρώτες απαιτήσεις.
Η σειρά της λίστας αντιστρέφεται στην επόμενη δομή επανάληψης με τη χρήση εντολών remove και add.Αφαιρούμε τα στοιχεία από την αρχή της λίστας και τα τοποθετούμε στο τέλος της .
Η τελευταία απαίτηση δηλαδή και η σύγκριση εάν όντως η ακολουθία είναι Watson-Crick γίνεται εάν συγκρίνοντας εάν ο πρώτος και ο τελευταίος κόμβος που αφαιρει κάθε φορά είναι συμπληρωματικοί.
